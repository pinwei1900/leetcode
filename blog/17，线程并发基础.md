线程应用的优势

- 建模更加简单，线程可以实现每次关注一件事情，避免使用单一程序造成的程序复杂性
- 可以接受对异步事件的处理，实现程序的及时响应
- 对于GUI程序来说，可以拥有更灵敏的响应

但是同时也带来了响应的风险

- 多线程程序可能是不安全的，在对同一个对象进行操作时候，很可能产生同步问题
- 有可能会发生死锁，这在单线程中是不会出现的
- 虽然线程有很多优点，但是操作系统在对线程进行调度的时候，不可避免的会消耗性能



如何修复同步问题

- 线程封闭，不在线程中共享此变量

- 将变量修改为不可变变量

- 使用同步，在访问此变量的时候使用


Java对象内置锁的特性

- 每一个对象都存在一个内置锁，一个Java对象的锁只能由一个线程进入
- 重入会给每一个对象锁关联一个计数器和所有者线程，对于这个线程是可以重入的



Java中共享对象可能出现的问题

- 共享对象不可见，线程B修改了变量x，但是线程A却知道x的旧值
- 共享数据失效，线程更新了一个失效的值
- 64位的long和double在内存中是两个字节，多线程环境下需要使用volatile或者锁进行保护



Java中同步关键字

- volatile   指出变量不会停留在寄存器中，可以保证读总在写之后。如果需要保证复合操作的原子性，应该只确保只有一个线程对变量进行写操作
- synchronized 同步代码块



线程安全

- 发布对象过程中，不要在对象的构造函数中构造匿名类，因为会隐含的发布this指针

- 将共享变量封闭在单线程内

- 确保volatile变量只有单个线程对此变量执行读取-修改-写入操作

- 栈中的局部变量是线程安全的，会始终封闭在线程中，可以在函数中实例化共享变量的复制版本

- ThreadLocal可以给每一个线程都保存一份独立的副本，get总是返回当前执行线程调用set时的最新值

- 将对象变成不可变对象，初始化时候就已经确定了对象的样子并且在生命周期内不可改变，比如枚举类，通过private和final，除非需要更高的可见性，都应该是private，除非需要改变，都应该是final


对象发布

- 避免不正确的对象创建，不要在没有足够同步的情况下创建对象，会导致其它线程看到尚未创建完成的对象，线程A在创建共享变量x，在x没有创建完成之前，可能会被其它的线程看到并进行调用。

- 创建不可变对象的初始化方法应该保证足够安全


安全发布常用方法

- 在静态初始化函数中初始化一个对象引用
- 将对象的引用保存到volatile域或者AtomicReferance对象中
- 将对象的引用保存到一个正确构造对象的final类型域中
- 将对象的引用保存在一个由锁保护的域中
- 通过一个健或者值放入HashTable，synchronizedMap或者ConcurrentMap中
- 放入Vector，CopyOnWriteArrayList，CopyOnWriteArraySet，synchronizedList或者synchronizedSet中
- 放入BlockingQueue或者ConcurrentLinkedQueue中
- Future和Exchanger
- 即使对象是可以进行修改的，但是如果对象事实上不会被修改，那么也可也保证线程安全，比如Date时间是可以被修改的，但是一般不会对此进行修改，就不需要在访问Date的时候进行同步操作
- 对于可变对象，需要保证：创建，访问，修改的同步机制，使用线程安全或者锁保护

最简单和最安全的发布方式

```java
public static Holder holder = new Holder(42);
```



共享对象的方法

- 线程封闭，只有一个线程对此变量进行修改
- 只读的，不需要额外的同步，任何线程都不能修改它，包括不可变对象和事实不可变对象
- 线程安全的对象在其内部实现同步，因此不需要进一步的同步
- 保护对象只能通过持有特定的锁来访问



同步的方式

- 直接使用synchronized 
- 使用监视器，创建一个私有锁
- 应当注意加锁的对象

