需要使用二进制协议的情况

- 性能要求非常严苛
- 数据本身带有大量的二进制内容，不适合文本格式
- 协议保密反侦测等
- 对端的软件已经处于某种目的使用了二进制协议



协议的基本单元——消息

- TCP协议要求连接关闭之后，协议双方需要保持WAIT状态一段时间（一般是两分钟），这段时间里相同的端口号是不能使用的，这样很容易导致客户端端口耗尽，而且建立连接和断开连接需要额外的开销

- 设计在单独的连接上处理多个甚至无限数量的消息，需要正确的对数据进行分片处理。
- 一个消息无论大小如何，都应该被看作是一个消息，逻辑上不可分割，但是可以做到一边接受一边处理



数据流的切分

- 基于文本的协议
  - 通过换行符进行分隔
  - 利用JSON和XML的结构化特性

- 基于二进制的数据
  - 在数据开头明确写出消息的长度，按照长度进行切分



消息解析机制

- 消息长度，作为消息切分的依据

- 消息类型，多种消息
- 消息版本，版本升级消息格式可能有变化
- 消息标识，在request中加入id，然后在reply中使用相同的id，可以解决请求和应答的顺序问题

> 使用两个单字节分别表示类型和版本，使用双字节表示消息长度，使用四字节表示消息ID，对于字节边界有利于读写速度的提升



消息类型

- 错误消息，需要专门的消息用来表示错误信息，比如请求无法解析，参数
- 应用层探活，

> 长链接中客户端和服务器需要有能向对方发送探活请求的能力，TCP的特性是如果不进行数据传输，则对端是无法察觉到网络中断这件事的，如果客户端发送的数据，这时网络中断，客户端会清除链接，但是由于网络中断服务器无法收到任何数据包会以为连接仍然正常，这样的连接服务器无法清除。所以服务器需要定期检测客户端是否通畅。

- RPC请求和响应



测试消息解析

- 协议定义完成之后应该使用单元测试检验是否存在问题



异步请求和pipelining

- 异步请求

> 传统的请求每一个线程处理一个socket，读取一个请求，处理返回，再读取写一个请求；但是这种请求只能一个一个处理，如果请求需要阻塞一段时间，则剩下的请求是不能接收的。如果请求可以以一种异步的方式处理，就可以同时接收多个请求，然后按照处理完成的时间进行响应

- pipelining

> 指的是请求方可以在响应返回之前一次发送大量的请求，然后再一次读取所有的响应。一般来说是通过一次请求一个相应进行的，但是这样网络延迟就很可能成为系统性能的瓶颈。可以考虑通过将多个请求组合成一个请求，以及将多个响应组成一个响应来提交系统效率。但是这里**请注意对内存的消耗**



结论

在设计自定义的二进制协议的过程中，实现消息的正确分片是最关键的部分。在协议中应该设计好双方向的探活机制，充分考虑到进行异步处理和pipelining的问题。