死锁的集中情况

- 锁顺序死锁 ：两个线程获取锁的方向正好相反
- 动态锁顺序死锁：需要仔细分析程序中是否存在获取锁顺序问题
- 在协作对象之间发生的死锁
- 开放调用，不要在方法上持有锁
- 资源死锁



死锁的避免

- 使锁支持定时，如果在获取锁超时，那么可以释放这个锁，并在一段时间后再次尝试
- 活锁：在随机时间之后尝试



思考性能的几个方面

- 提升性能意味者使用更少的资源做更多的事情
- 尽管多线程可以提升整体性能，但是与单线程相比，多线程总会引入一些额外的性能开销，比如上下文切换，线程之间的协调， 线程创建和销毁，线程调度。
- 如何更有效的利用现有的处理资源
- 如果在出现新的处理资源时使程序尽可能的利用这些新资源
- CPU需要尽可能的处于忙碌状态，并避免浪费在一些无用的计算上
- 程序需要有可伸缩性，意味者在增加计算资源时，系统的吞吐量或者处理能力能相应的增加



评估性能时

- 首先使程序正确，然后再提高速度
- 不要猜测，以测试为基准
- 在评估系统性能时，需要首先确定系统中必须串行执行的部分，其次再确定这些部分中可以并行执行的部分



线程引入的开销

- 上下文切换
- 内存同步
- 阻塞



减少锁的竞争

- 缩小锁的范围，快进快出
- 缩小锁的粒度
- 锁分段
- 避免热点域，比如多个操作都需要涉及到某个变量的修改就是热点域，比如HashMap中的size
- 代替独占锁：ReadWriteLock，原子变量



CPU没有得到充分利用的几个原因

- 负载不充足
- IO密集，可以使用iostat，或者perfmon来判断某个应用是否是磁盘IO密集，或通过检测网络通信流量判断是否需要高带宽
- 外部限制，应用程序依赖于外部程序，比如数据库或者Web服务
- 锁竞争



