同步容器类

- Vector
- Hashtable

> 对每个公共方法都进行同步，使得每次只有一个线程可以访问容器的状态。即使是同步容器，仍然需要在复合操作中对容器进行同步。但是这在对大批量数据进行循环的时候可能会造成性能问题，导致许多线程在等待锁被释放。一种解决的方式是对数据进行克隆



并发容器

- ConcurrentHashMap

>  此容器并不是每一个方法都在同一个锁上同步，也不是每一次都只能有一个线程访问容器。它使用了一种更加细粒度的加锁机制——分段锁。这种机制里任意数量的读取线程可以并发的访问Map。此容器不会在迭代时抛出异常，而是在修改后尽量的把修改操作展示出来。但是不能保证在整体概念上的计算，比如size和isEmpty方法，只是一个近似值而不是一个精确值。

- CopyOnWriteArrayList

> 此容器在每次修改的时候都会创建并重新发布一个新的容器副本从而实现可变性



阻塞队列（消费者模式）

- LinkedBlockingQueue
- ArrayBlockingQueue
- PriorityBlockingQueue  按照某种顺序处理元素
- SynchronousQueue 实际上是维护了一组线程等待着把元素加入或者移出队列
- BlockingDeque 可以在队列两端进行插入和移除，当一个工作线程找到新的工作单元时，会将其放到自己队列的末尾，当自己的队列为空时，会在另一个队列的尾端查找新的任务



同步工具类

- ConutDownLatch（闭锁）

> 相当于是一扇门，在闭锁到达结束状态（零）之前，这扇门一直是关闭的

- FutureTask

> 此类表示异步任务。如果任务已经完成，get会立即返回结果，否则将阻塞直到任务进入完成状态，然后返回结果或抛出异常。

- Semaphore（信号量）

> 计数信号量用来控制同时访问某个特定资源的操作数量

- CyclicBarrier（栅栏）

> 类似于闭锁，它能阻塞一组线程，只有所有线程都到达了栅栏位置才能继续执行，可以使用在并行迭代算法中