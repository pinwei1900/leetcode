重排序

> JMM规定了只要程序的最终结果与在严格串行环境中执行的结果相同，那么所有操作都是被允许的



JMM中的偏序关系（happens-before）

- 程序顺序：如果程序中操作A在操作B之前，那么A在B之前执行
- 监视器锁：在监视器锁上的解锁必须在同一个监视器锁上加锁之前执行（反过来也一样）
- volatile变量：对该类变量的写入操作比如在该变量的读操作之前（反过来也一样）
- 线程启动：在线程上对Thread.start的调用必须在该线程中执行任何操作之前执行
- 线程结束：线程中的任何操作都必须在其它线程检测到该线程已经结束之前执行，或Thread.join返回之前，或在调用Thread.isAlive返回false
- 中断：一个线程在调用另一个线程的interrupt时，必须在被中断程序检测到中断之前执行
- 终结器：对想的构造函数必须在启动对象的终结器之前执行完成
- 传递性：如果操作A在操作B之前，并且B在C之前，那么操作A必须在操作C之前执行



安全的发布

- 延迟初始化：给初始化方法加锁
- 提前初始化：使用静态初始化
- 双重检查加锁（糟糕的方法）：尽量不要使用此方法，该方法有可能会返回一个旧值（避免此问题的方式是在变量声明中使用volatile）

